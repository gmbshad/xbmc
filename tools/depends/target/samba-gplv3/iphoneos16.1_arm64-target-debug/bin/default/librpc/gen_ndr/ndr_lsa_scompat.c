/* s3 compat server functions auto-generated by pidl */
#include "bin/default/librpc/gen_ndr/ndr_lsa.h"
#include "bin/default/librpc/gen_ndr/ndr_lsa_scompat.h"
#include <librpc/rpc/dcesrv_core.h>
#include <rpc_server/rpc_config.h>
#include <rpc_server/rpc_server.h>
#include <util/debug.h>

enum s3compat_rpc_dispatch {
	S3COMPAT_RPC_DISPATCH_EXTERNAL = 0x00000001,
	S3COMPAT_RPC_DISPATCH_INTERNAL = 0x00000002,
};

/* lsarpc - dcerpc server boilerplate generated by pidl */
static NTSTATUS lsarpc__op_bind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
	struct pipes_struct *p = NULL;

	/* Retrieve pipes struct */
	p = dcesrv_get_pipes_struct(context->conn);
	p->pipe_bound = true;
#ifdef DCESRV_INTERFACE_LSARPC_BIND
	return DCESRV_INTERFACE_LSARPC_BIND(context,iface);
#else
	return NT_STATUS_OK;
#endif
}

static void lsarpc__op_unbind(struct dcesrv_connection_context *context, const struct dcesrv_interface *iface)
{
#ifdef DCESRV_INTERFACE_LSARPC_UNBIND
	DCESRV_INTERFACE_LSARPC_UNBIND(context, iface);
#else
	return;
#endif
}

NTSTATUS lsarpc__op_ndr_pull(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_pull *pull, void **r)
{
	enum ndr_err_code ndr_err;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	dce_call->fault_code = 0;

	if (opnum >= ndr_table_lsarpc.num_calls) {
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	*r = talloc_named(mem_ctx, ndr_table_lsarpc.calls[opnum].struct_size, "struct %s", ndr_table_lsarpc.calls[opnum].name);
	NT_STATUS_HAVE_NO_MEMORY(*r);

	/* unravel the NDR for the packet */
	ndr_err = ndr_table_lsarpc.calls[opnum].ndr_pull(pull, NDR_IN, *r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

static NTSTATUS lsarpc__op_dispatch_internal(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r, enum s3compat_rpc_dispatch dispatch)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;
	struct pipes_struct *p = NULL;
	struct auth_session_info *pipe_session_info = NULL;
	NTSTATUS status = NT_STATUS_OK;
	bool impersonated = false;

	/* Retrieve pipes struct */
	p = dcesrv_get_pipes_struct(dce_call->conn);
	/* Update pipes struct opnum */
	p->opnum = opnum;
	p->dce_call = dce_call;
	p->mem_ctx = mem_ctx;
	/* Update pipes struct session info */
	pipe_session_info = p->session_info;
	p->session_info = dce_call->auth_state->session_info;
	p->auth.auth_type = dce_call->auth_state->auth_type;
	p->auth.auth_level = dce_call->auth_state->auth_level;
	p->auth.auth_context_id = dce_call->auth_state->auth_context_id;
	/* Reset pipes struct fault state */
	p->fault_state = 0;

	/* Impersonate */
	if (dispatch == S3COMPAT_RPC_DISPATCH_EXTERNAL) {
		impersonated = become_authenticated_pipe_user(p->session_info);
		if (!impersonated) {
			dce_call->fault_code = DCERPC_FAULT_ACCESS_DENIED;
			status = NT_STATUS_NET_WRITE_FAULT;
			goto fail;
		}
	}

	switch (opnum) {
	case 0: { /* lsa_Close */
		struct lsa_Close *r2 = (struct lsa_Close *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_Close, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.handle = r2->in.handle;
		r2->out.result = _lsa_Close(p, r2);
		break;
	}
	case 1: { /* lsa_Delete */
		struct lsa_Delete *r2 = (struct lsa_Delete *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_Delete, NDR_IN, r2);
		}
		r2->out.result = _lsa_Delete(p, r2);
		break;
	}
	case 2: { /* lsa_EnumPrivs */
		struct lsa_EnumPrivs *r2 = (struct lsa_EnumPrivs *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumPrivs, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.resume_handle = r2->in.resume_handle;
		r2->out.privs = talloc_zero(r2, struct lsa_PrivArray);
		if (r2->out.privs == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumPrivs(p, r2);
		break;
	}
	case 3: { /* lsa_QuerySecurity */
		struct lsa_QuerySecurity *r2 = (struct lsa_QuerySecurity *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QuerySecurity, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sdbuf = talloc_zero(r2, struct sec_desc_buf *);
		if (r2->out.sdbuf == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QuerySecurity(p, r2);
		break;
	}
	case 4: { /* lsa_SetSecObj */
		struct lsa_SetSecObj *r2 = (struct lsa_SetSecObj *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSecObj, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetSecObj(p, r2);
		break;
	}
	case 5: { /* lsa_ChangePassword */
		struct lsa_ChangePassword *r2 = (struct lsa_ChangePassword *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_ChangePassword, NDR_IN, r2);
		}
		r2->out.result = _lsa_ChangePassword(p, r2);
		break;
	}
	case 6: { /* lsa_OpenPolicy */
		struct lsa_OpenPolicy *r2 = (struct lsa_OpenPolicy *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenPolicy, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenPolicy(p, r2);
		break;
	}
	case 7: { /* lsa_QueryInfoPolicy */
		struct lsa_QueryInfoPolicy *r2 = (struct lsa_QueryInfoPolicy *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryInfoPolicy, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_PolicyInformation *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryInfoPolicy(p, r2);
		break;
	}
	case 8: { /* lsa_SetInfoPolicy */
		struct lsa_SetInfoPolicy *r2 = (struct lsa_SetInfoPolicy *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInfoPolicy, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetInfoPolicy(p, r2);
		break;
	}
	case 9: { /* lsa_ClearAuditLog */
		struct lsa_ClearAuditLog *r2 = (struct lsa_ClearAuditLog *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_ClearAuditLog, NDR_IN, r2);
		}
		r2->out.result = _lsa_ClearAuditLog(p, r2);
		break;
	}
	case 10: { /* lsa_CreateAccount */
		struct lsa_CreateAccount *r2 = (struct lsa_CreateAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateAccount, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.acct_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.acct_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_CreateAccount(p, r2);
		break;
	}
	case 11: { /* lsa_EnumAccounts */
		struct lsa_EnumAccounts *r2 = (struct lsa_EnumAccounts *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccounts, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.resume_handle = r2->in.resume_handle;
		r2->out.sids = talloc_zero(r2, struct lsa_SidArray);
		if (r2->out.sids == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumAccounts(p, r2);
		break;
	}
	case 12: { /* lsa_CreateTrustedDomain */
		struct lsa_CreateTrustedDomain *r2 = (struct lsa_CreateTrustedDomain *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomain, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.trustdom_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.trustdom_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_CreateTrustedDomain(p, r2);
		break;
	}
	case 13: { /* lsa_EnumTrustDom */
		struct lsa_EnumTrustDom *r2 = (struct lsa_EnumTrustDom *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumTrustDom, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.resume_handle = r2->in.resume_handle;
		r2->out.domains = talloc_zero(r2, struct lsa_DomainList);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumTrustDom(p, r2);
		break;
	}
	case 14: { /* lsa_LookupNames */
		struct lsa_LookupNames *r2 = (struct lsa_LookupNames *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sids = r2->in.sids;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupNames(p, r2);
		break;
	}
	case 15: { /* lsa_LookupSids */
		struct lsa_LookupSids *r2 = (struct lsa_LookupSids *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.names = r2->in.names;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupSids(p, r2);
		break;
	}
	case 16: { /* lsa_CreateSecret */
		struct lsa_CreateSecret *r2 = (struct lsa_CreateSecret *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateSecret, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sec_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.sec_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_CreateSecret(p, r2);
		break;
	}
	case 17: { /* lsa_OpenAccount */
		struct lsa_OpenAccount *r2 = (struct lsa_OpenAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenAccount, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.acct_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.acct_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenAccount(p, r2);
		break;
	}
	case 18: { /* lsa_EnumPrivsAccount */
		struct lsa_EnumPrivsAccount *r2 = (struct lsa_EnumPrivsAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumPrivsAccount, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.privs = talloc_zero(r2, struct lsa_PrivilegeSet *);
		if (r2->out.privs == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumPrivsAccount(p, r2);
		break;
	}
	case 19: { /* lsa_AddPrivilegesToAccount */
		struct lsa_AddPrivilegesToAccount *r2 = (struct lsa_AddPrivilegesToAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_AddPrivilegesToAccount, NDR_IN, r2);
		}
		r2->out.result = _lsa_AddPrivilegesToAccount(p, r2);
		break;
	}
	case 20: { /* lsa_RemovePrivilegesFromAccount */
		struct lsa_RemovePrivilegesFromAccount *r2 = (struct lsa_RemovePrivilegesFromAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RemovePrivilegesFromAccount, NDR_IN, r2);
		}
		r2->out.result = _lsa_RemovePrivilegesFromAccount(p, r2);
		break;
	}
	case 21: { /* lsa_GetQuotasForAccount */
		struct lsa_GetQuotasForAccount *r2 = (struct lsa_GetQuotasForAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetQuotasForAccount, NDR_IN, r2);
		}
		r2->out.result = _lsa_GetQuotasForAccount(p, r2);
		break;
	}
	case 22: { /* lsa_SetQuotasForAccount */
		struct lsa_SetQuotasForAccount *r2 = (struct lsa_SetQuotasForAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetQuotasForAccount, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetQuotasForAccount(p, r2);
		break;
	}
	case 23: { /* lsa_GetSystemAccessAccount */
		struct lsa_GetSystemAccessAccount *r2 = (struct lsa_GetSystemAccessAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetSystemAccessAccount, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.access_mask = talloc_zero(r2, uint32_t);
		if (r2->out.access_mask == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_GetSystemAccessAccount(p, r2);
		break;
	}
	case 24: { /* lsa_SetSystemAccessAccount */
		struct lsa_SetSystemAccessAccount *r2 = (struct lsa_SetSystemAccessAccount *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSystemAccessAccount, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetSystemAccessAccount(p, r2);
		break;
	}
	case 25: { /* lsa_OpenTrustedDomain */
		struct lsa_OpenTrustedDomain *r2 = (struct lsa_OpenTrustedDomain *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenTrustedDomain, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.trustdom_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.trustdom_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenTrustedDomain(p, r2);
		break;
	}
	case 26: { /* lsa_QueryTrustedDomainInfo */
		struct lsa_QueryTrustedDomainInfo *r2 = (struct lsa_QueryTrustedDomainInfo *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfo, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_TrustedDomainInfo *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryTrustedDomainInfo(p, r2);
		break;
	}
	case 27: { /* lsa_SetInformationTrustedDomain */
		struct lsa_SetInformationTrustedDomain *r2 = (struct lsa_SetInformationTrustedDomain *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInformationTrustedDomain, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetInformationTrustedDomain(p, r2);
		break;
	}
	case 28: { /* lsa_OpenSecret */
		struct lsa_OpenSecret *r2 = (struct lsa_OpenSecret *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenSecret, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sec_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.sec_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenSecret(p, r2);
		break;
	}
	case 29: { /* lsa_SetSecret */
		struct lsa_SetSecret *r2 = (struct lsa_SetSecret *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSecret, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetSecret(p, r2);
		break;
	}
	case 30: { /* lsa_QuerySecret */
		struct lsa_QuerySecret *r2 = (struct lsa_QuerySecret *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QuerySecret, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.new_val = r2->in.new_val;
		r2->out.new_mtime = r2->in.new_mtime;
		r2->out.old_val = r2->in.old_val;
		r2->out.old_mtime = r2->in.old_mtime;
		r2->out.result = _lsa_QuerySecret(p, r2);
		break;
	}
	case 31: { /* lsa_LookupPrivValue */
		struct lsa_LookupPrivValue *r2 = (struct lsa_LookupPrivValue *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivValue, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.luid = talloc_zero(r2, struct lsa_LUID);
		if (r2->out.luid == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupPrivValue(p, r2);
		break;
	}
	case 32: { /* lsa_LookupPrivName */
		struct lsa_LookupPrivName *r2 = (struct lsa_LookupPrivName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivName, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.name = talloc_zero(r2, struct lsa_StringLarge *);
		if (r2->out.name == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupPrivName(p, r2);
		break;
	}
	case 33: { /* lsa_LookupPrivDisplayName */
		struct lsa_LookupPrivDisplayName *r2 = (struct lsa_LookupPrivDisplayName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivDisplayName, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.disp_name = talloc_zero(r2, struct lsa_StringLarge *);
		if (r2->out.disp_name == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.returned_language_id = talloc_zero(r2, uint16_t);
		if (r2->out.returned_language_id == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupPrivDisplayName(p, r2);
		break;
	}
	case 34: { /* lsa_DeleteObject */
		struct lsa_DeleteObject *r2 = (struct lsa_DeleteObject *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_DeleteObject, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.handle = r2->in.handle;
		r2->out.result = _lsa_DeleteObject(p, r2);
		break;
	}
	case 35: { /* lsa_EnumAccountsWithUserRight */
		struct lsa_EnumAccountsWithUserRight *r2 = (struct lsa_EnumAccountsWithUserRight *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccountsWithUserRight, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sids = talloc_zero(r2, struct lsa_SidArray);
		if (r2->out.sids == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumAccountsWithUserRight(p, r2);
		break;
	}
	case 36: { /* lsa_EnumAccountRights */
		struct lsa_EnumAccountRights *r2 = (struct lsa_EnumAccountRights *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccountRights, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.rights = talloc_zero(r2, struct lsa_RightSet);
		if (r2->out.rights == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumAccountRights(p, r2);
		break;
	}
	case 37: { /* lsa_AddAccountRights */
		struct lsa_AddAccountRights *r2 = (struct lsa_AddAccountRights *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_AddAccountRights, NDR_IN, r2);
		}
		r2->out.result = _lsa_AddAccountRights(p, r2);
		break;
	}
	case 38: { /* lsa_RemoveAccountRights */
		struct lsa_RemoveAccountRights *r2 = (struct lsa_RemoveAccountRights *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RemoveAccountRights, NDR_IN, r2);
		}
		r2->out.result = _lsa_RemoveAccountRights(p, r2);
		break;
	}
	case 39: { /* lsa_QueryTrustedDomainInfoBySid */
		struct lsa_QueryTrustedDomainInfoBySid *r2 = (struct lsa_QueryTrustedDomainInfoBySid *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfoBySid, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_TrustedDomainInfo *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryTrustedDomainInfoBySid(p, r2);
		break;
	}
	case 40: { /* lsa_SetTrustedDomainInfo */
		struct lsa_SetTrustedDomainInfo *r2 = (struct lsa_SetTrustedDomainInfo *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetTrustedDomainInfo, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetTrustedDomainInfo(p, r2);
		break;
	}
	case 41: { /* lsa_DeleteTrustedDomain */
		struct lsa_DeleteTrustedDomain *r2 = (struct lsa_DeleteTrustedDomain *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_DeleteTrustedDomain, NDR_IN, r2);
		}
		r2->out.result = _lsa_DeleteTrustedDomain(p, r2);
		break;
	}
	case 42: { /* lsa_StorePrivateData */
		struct lsa_StorePrivateData *r2 = (struct lsa_StorePrivateData *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_StorePrivateData, NDR_IN, r2);
		}
		r2->out.result = _lsa_StorePrivateData(p, r2);
		break;
	}
	case 43: { /* lsa_RetrievePrivateData */
		struct lsa_RetrievePrivateData *r2 = (struct lsa_RetrievePrivateData *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RetrievePrivateData, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.val = r2->in.val;
		r2->out.result = _lsa_RetrievePrivateData(p, r2);
		break;
	}
	case 44: { /* lsa_OpenPolicy2 */
		struct lsa_OpenPolicy2 *r2 = (struct lsa_OpenPolicy2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenPolicy2, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenPolicy2(p, r2);
		break;
	}
	case 45: { /* lsa_GetUserName */
		struct lsa_GetUserName *r2 = (struct lsa_GetUserName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetUserName, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.account_name = r2->in.account_name;
		r2->out.authority_name = r2->in.authority_name;
		r2->out.result = _lsa_GetUserName(p, r2);
		break;
	}
	case 46: { /* lsa_QueryInfoPolicy2 */
		struct lsa_QueryInfoPolicy2 *r2 = (struct lsa_QueryInfoPolicy2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryInfoPolicy2, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_PolicyInformation *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryInfoPolicy2(p, r2);
		break;
	}
	case 47: { /* lsa_SetInfoPolicy2 */
		struct lsa_SetInfoPolicy2 *r2 = (struct lsa_SetInfoPolicy2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInfoPolicy2, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetInfoPolicy2(p, r2);
		break;
	}
	case 48: { /* lsa_QueryTrustedDomainInfoByName */
		struct lsa_QueryTrustedDomainInfoByName *r2 = (struct lsa_QueryTrustedDomainInfoByName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfoByName, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_TrustedDomainInfo *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryTrustedDomainInfoByName(p, r2);
		break;
	}
	case 49: { /* lsa_SetTrustedDomainInfoByName */
		struct lsa_SetTrustedDomainInfoByName *r2 = (struct lsa_SetTrustedDomainInfoByName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetTrustedDomainInfoByName, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetTrustedDomainInfoByName(p, r2);
		break;
	}
	case 50: { /* lsa_EnumTrustedDomainsEx */
		struct lsa_EnumTrustedDomainsEx *r2 = (struct lsa_EnumTrustedDomainsEx *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumTrustedDomainsEx, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.resume_handle = r2->in.resume_handle;
		r2->out.domains = talloc_zero(r2, struct lsa_DomainListEx);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_EnumTrustedDomainsEx(p, r2);
		break;
	}
	case 51: { /* lsa_CreateTrustedDomainEx */
		struct lsa_CreateTrustedDomainEx *r2 = (struct lsa_CreateTrustedDomainEx *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomainEx, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.trustdom_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.trustdom_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_CreateTrustedDomainEx(p, r2);
		break;
	}
	case 52: { /* lsa_CloseTrustedDomainEx */
		struct lsa_CloseTrustedDomainEx *r2 = (struct lsa_CloseTrustedDomainEx *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CloseTrustedDomainEx, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.handle = r2->in.handle;
		r2->out.result = _lsa_CloseTrustedDomainEx(p, r2);
		break;
	}
	case 53: { /* lsa_QueryDomainInformationPolicy */
		struct lsa_QueryDomainInformationPolicy *r2 = (struct lsa_QueryDomainInformationPolicy *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryDomainInformationPolicy, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.info = talloc_zero(r2, union lsa_DomainInformationPolicy *);
		if (r2->out.info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_QueryDomainInformationPolicy(p, r2);
		break;
	}
	case 54: { /* lsa_SetDomainInformationPolicy */
		struct lsa_SetDomainInformationPolicy *r2 = (struct lsa_SetDomainInformationPolicy *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetDomainInformationPolicy, NDR_IN, r2);
		}
		r2->out.result = _lsa_SetDomainInformationPolicy(p, r2);
		break;
	}
	case 55: { /* lsa_OpenTrustedDomainByName */
		struct lsa_OpenTrustedDomainByName *r2 = (struct lsa_OpenTrustedDomainByName *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenTrustedDomainByName, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.trustdom_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.trustdom_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_OpenTrustedDomainByName(p, r2);
		break;
	}
	case 56: { /* lsa_TestCall */
		struct lsa_TestCall *r2 = (struct lsa_TestCall *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_TestCall, NDR_IN, r2);
		}
		r2->out.result = _lsa_TestCall(p, r2);
		break;
	}
	case 57: { /* lsa_LookupSids2 */
		struct lsa_LookupSids2 *r2 = (struct lsa_LookupSids2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids2, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.names = r2->in.names;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupSids2(p, r2);
		break;
	}
	case 58: { /* lsa_LookupNames2 */
		struct lsa_LookupNames2 *r2 = (struct lsa_LookupNames2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames2, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sids = r2->in.sids;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupNames2(p, r2);
		break;
	}
	case 59: { /* lsa_CreateTrustedDomainEx2 */
		struct lsa_CreateTrustedDomainEx2 *r2 = (struct lsa_CreateTrustedDomainEx2 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomainEx2, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.trustdom_handle = talloc_zero(r2, struct policy_handle);
		if (r2->out.trustdom_handle == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_CreateTrustedDomainEx2(p, r2);
		break;
	}
	case 60: { /* lsa_CREDRWRITE */
		struct lsa_CREDRWRITE *r2 = (struct lsa_CREDRWRITE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRWRITE, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRWRITE(p, r2);
		break;
	}
	case 61: { /* lsa_CREDRREAD */
		struct lsa_CREDRREAD *r2 = (struct lsa_CREDRREAD *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRREAD, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRREAD(p, r2);
		break;
	}
	case 62: { /* lsa_CREDRENUMERATE */
		struct lsa_CREDRENUMERATE *r2 = (struct lsa_CREDRENUMERATE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRENUMERATE, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRENUMERATE(p, r2);
		break;
	}
	case 63: { /* lsa_CREDRWRITEDOMAINCREDENTIALS */
		struct lsa_CREDRWRITEDOMAINCREDENTIALS *r2 = (struct lsa_CREDRWRITEDOMAINCREDENTIALS *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRWRITEDOMAINCREDENTIALS, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRWRITEDOMAINCREDENTIALS(p, r2);
		break;
	}
	case 64: { /* lsa_CREDRREADDOMAINCREDENTIALS */
		struct lsa_CREDRREADDOMAINCREDENTIALS *r2 = (struct lsa_CREDRREADDOMAINCREDENTIALS *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRREADDOMAINCREDENTIALS, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRREADDOMAINCREDENTIALS(p, r2);
		break;
	}
	case 65: { /* lsa_CREDRDELETE */
		struct lsa_CREDRDELETE *r2 = (struct lsa_CREDRDELETE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRDELETE, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRDELETE(p, r2);
		break;
	}
	case 66: { /* lsa_CREDRGETTARGETINFO */
		struct lsa_CREDRGETTARGETINFO *r2 = (struct lsa_CREDRGETTARGETINFO *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRGETTARGETINFO, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRGETTARGETINFO(p, r2);
		break;
	}
	case 67: { /* lsa_CREDRPROFILELOADED */
		struct lsa_CREDRPROFILELOADED *r2 = (struct lsa_CREDRPROFILELOADED *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRPROFILELOADED, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRPROFILELOADED(p, r2);
		break;
	}
	case 68: { /* lsa_LookupNames3 */
		struct lsa_LookupNames3 *r2 = (struct lsa_LookupNames3 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames3, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sids = r2->in.sids;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupNames3(p, r2);
		break;
	}
	case 69: { /* lsa_CREDRGETSESSIONTYPES */
		struct lsa_CREDRGETSESSIONTYPES *r2 = (struct lsa_CREDRGETSESSIONTYPES *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRGETSESSIONTYPES, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRGETSESSIONTYPES(p, r2);
		break;
	}
	case 70: { /* lsa_LSARREGISTERAUDITEVENT */
		struct lsa_LSARREGISTERAUDITEVENT *r2 = (struct lsa_LSARREGISTERAUDITEVENT *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARREGISTERAUDITEVENT, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARREGISTERAUDITEVENT(p, r2);
		break;
	}
	case 71: { /* lsa_LSARGENAUDITEVENT */
		struct lsa_LSARGENAUDITEVENT *r2 = (struct lsa_LSARGENAUDITEVENT *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARGENAUDITEVENT, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARGENAUDITEVENT(p, r2);
		break;
	}
	case 72: { /* lsa_LSARUNREGISTERAUDITEVENT */
		struct lsa_LSARUNREGISTERAUDITEVENT *r2 = (struct lsa_LSARUNREGISTERAUDITEVENT *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARUNREGISTERAUDITEVENT, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARUNREGISTERAUDITEVENT(p, r2);
		break;
	}
	case 73: { /* lsa_lsaRQueryForestTrustInformation */
		struct lsa_lsaRQueryForestTrustInformation *r2 = (struct lsa_lsaRQueryForestTrustInformation *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_lsaRQueryForestTrustInformation, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.forest_trust_info = talloc_zero(r2, struct lsa_ForestTrustInformation *);
		if (r2->out.forest_trust_info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_lsaRQueryForestTrustInformation(p, r2);
		break;
	}
	case 74: { /* lsa_lsaRSetForestTrustInformation */
		struct lsa_lsaRSetForestTrustInformation *r2 = (struct lsa_lsaRSetForestTrustInformation *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_lsaRSetForestTrustInformation, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.collision_info = talloc_zero(r2, struct lsa_ForestTrustCollisionInfo *);
		if (r2->out.collision_info == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_lsaRSetForestTrustInformation(p, r2);
		break;
	}
	case 75: { /* lsa_CREDRRENAME */
		struct lsa_CREDRRENAME *r2 = (struct lsa_CREDRRENAME *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRRENAME, NDR_IN, r2);
		}
		r2->out.result = _lsa_CREDRRENAME(p, r2);
		break;
	}
	case 76: { /* lsa_LookupSids3 */
		struct lsa_LookupSids3 *r2 = (struct lsa_LookupSids3 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids3, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.names = r2->in.names;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupSids3(p, r2);
		break;
	}
	case 77: { /* lsa_LookupNames4 */
		struct lsa_LookupNames4 *r2 = (struct lsa_LookupNames4 *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames4, NDR_IN, r2);
		}
		NDR_ZERO_STRUCT(r2->out);
		r2->out.sids = r2->in.sids;
		r2->out.count = r2->in.count;
		r2->out.domains = talloc_zero(r2, struct lsa_RefDomainList *);
		if (r2->out.domains == NULL) {
			status = NT_STATUS_NO_MEMORY;
			p->fault_state = DCERPC_FAULT_CANT_PERFORM;
			goto fail;
		}

		r2->out.result = _lsa_LookupNames4(p, r2);
		break;
	}
	case 78: { /* lsa_LSAROPENPOLICYSCE */
		struct lsa_LSAROPENPOLICYSCE *r2 = (struct lsa_LSAROPENPOLICYSCE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSAROPENPOLICYSCE, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSAROPENPOLICYSCE(p, r2);
		break;
	}
	case 79: { /* lsa_LSARADTREGISTERSECURITYEVENTSOURCE */
		struct lsa_LSARADTREGISTERSECURITYEVENTSOURCE *r2 = (struct lsa_LSARADTREGISTERSECURITYEVENTSOURCE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTREGISTERSECURITYEVENTSOURCE, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARADTREGISTERSECURITYEVENTSOURCE(p, r2);
		break;
	}
	case 80: { /* lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE */
		struct lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE *r2 = (struct lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE(p, r2);
		break;
	}
	case 81: { /* lsa_LSARADTREPORTSECURITYEVENT */
		struct lsa_LSARADTREPORTSECURITYEVENT *r2 = (struct lsa_LSARADTREPORTSECURITYEVENT *)r;
		if (DEBUGLEVEL >= 10) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTREPORTSECURITYEVENT, NDR_IN, r2);
		}
		r2->out.result = _lsa_LSARADTREPORTSECURITYEVENT(p, r2);
		break;
	}
	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

fail:
	/* Unimpersonate */
	if (impersonated) {
		unbecome_authenticated_pipe_user();
	}

	p->dce_call = NULL;
	p->mem_ctx = NULL;
	/* Restore session info */
	p->session_info = pipe_session_info;
	p->auth.auth_type = 0;
	p->auth.auth_level = 0;
	p->auth.auth_context_id = 0;
	/* Check pipes struct fault state */
	if (p->fault_state != 0) {
		dce_call->fault_code = p->fault_state;
	}
	if (dce_call->fault_code != 0) {
		status = NT_STATUS_NET_WRITE_FAULT;
	}

	return status;
}

NTSTATUS lsarpc__op_dispatch(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	return lsarpc__op_dispatch_internal(dce_call, mem_ctx, r, S3COMPAT_RPC_DISPATCH_EXTERNAL);
}

NTSTATUS lsarpc__op_reply(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	switch (opnum) {
	case 0: { /* lsa_Close */
		struct lsa_Close *r2 = (struct lsa_Close *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_Close replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_Close, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_Close\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 1: { /* lsa_Delete */
		struct lsa_Delete *r2 = (struct lsa_Delete *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_Delete replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_Delete, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_Delete\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 2: { /* lsa_EnumPrivs */
		struct lsa_EnumPrivs *r2 = (struct lsa_EnumPrivs *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumPrivs replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumPrivs, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumPrivs\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 3: { /* lsa_QuerySecurity */
		struct lsa_QuerySecurity *r2 = (struct lsa_QuerySecurity *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QuerySecurity replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QuerySecurity, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QuerySecurity\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 4: { /* lsa_SetSecObj */
		struct lsa_SetSecObj *r2 = (struct lsa_SetSecObj *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetSecObj replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSecObj, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetSecObj\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 5: { /* lsa_ChangePassword */
		struct lsa_ChangePassword *r2 = (struct lsa_ChangePassword *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_ChangePassword replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_ChangePassword, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_ChangePassword\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 6: { /* lsa_OpenPolicy */
		struct lsa_OpenPolicy *r2 = (struct lsa_OpenPolicy *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenPolicy replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenPolicy, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenPolicy\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 7: { /* lsa_QueryInfoPolicy */
		struct lsa_QueryInfoPolicy *r2 = (struct lsa_QueryInfoPolicy *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryInfoPolicy replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryInfoPolicy, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryInfoPolicy\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 8: { /* lsa_SetInfoPolicy */
		struct lsa_SetInfoPolicy *r2 = (struct lsa_SetInfoPolicy *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetInfoPolicy replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInfoPolicy, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetInfoPolicy\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 9: { /* lsa_ClearAuditLog */
		struct lsa_ClearAuditLog *r2 = (struct lsa_ClearAuditLog *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_ClearAuditLog replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_ClearAuditLog, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_ClearAuditLog\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 10: { /* lsa_CreateAccount */
		struct lsa_CreateAccount *r2 = (struct lsa_CreateAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CreateAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CreateAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 11: { /* lsa_EnumAccounts */
		struct lsa_EnumAccounts *r2 = (struct lsa_EnumAccounts *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumAccounts replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccounts, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumAccounts\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 12: { /* lsa_CreateTrustedDomain */
		struct lsa_CreateTrustedDomain *r2 = (struct lsa_CreateTrustedDomain *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CreateTrustedDomain replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomain, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CreateTrustedDomain\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 13: { /* lsa_EnumTrustDom */
		struct lsa_EnumTrustDom *r2 = (struct lsa_EnumTrustDom *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumTrustDom replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumTrustDom, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumTrustDom\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 14: { /* lsa_LookupNames */
		struct lsa_LookupNames *r2 = (struct lsa_LookupNames *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupNames replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupNames\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 15: { /* lsa_LookupSids */
		struct lsa_LookupSids *r2 = (struct lsa_LookupSids *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupSids replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupSids\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 16: { /* lsa_CreateSecret */
		struct lsa_CreateSecret *r2 = (struct lsa_CreateSecret *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CreateSecret replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateSecret, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CreateSecret\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 17: { /* lsa_OpenAccount */
		struct lsa_OpenAccount *r2 = (struct lsa_OpenAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 18: { /* lsa_EnumPrivsAccount */
		struct lsa_EnumPrivsAccount *r2 = (struct lsa_EnumPrivsAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumPrivsAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumPrivsAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumPrivsAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 19: { /* lsa_AddPrivilegesToAccount */
		struct lsa_AddPrivilegesToAccount *r2 = (struct lsa_AddPrivilegesToAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_AddPrivilegesToAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_AddPrivilegesToAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_AddPrivilegesToAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 20: { /* lsa_RemovePrivilegesFromAccount */
		struct lsa_RemovePrivilegesFromAccount *r2 = (struct lsa_RemovePrivilegesFromAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_RemovePrivilegesFromAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RemovePrivilegesFromAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_RemovePrivilegesFromAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 21: { /* lsa_GetQuotasForAccount */
		struct lsa_GetQuotasForAccount *r2 = (struct lsa_GetQuotasForAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_GetQuotasForAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetQuotasForAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_GetQuotasForAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 22: { /* lsa_SetQuotasForAccount */
		struct lsa_SetQuotasForAccount *r2 = (struct lsa_SetQuotasForAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetQuotasForAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetQuotasForAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetQuotasForAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 23: { /* lsa_GetSystemAccessAccount */
		struct lsa_GetSystemAccessAccount *r2 = (struct lsa_GetSystemAccessAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_GetSystemAccessAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetSystemAccessAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_GetSystemAccessAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 24: { /* lsa_SetSystemAccessAccount */
		struct lsa_SetSystemAccessAccount *r2 = (struct lsa_SetSystemAccessAccount *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetSystemAccessAccount replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSystemAccessAccount, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetSystemAccessAccount\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 25: { /* lsa_OpenTrustedDomain */
		struct lsa_OpenTrustedDomain *r2 = (struct lsa_OpenTrustedDomain *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenTrustedDomain replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenTrustedDomain, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenTrustedDomain\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 26: { /* lsa_QueryTrustedDomainInfo */
		struct lsa_QueryTrustedDomainInfo *r2 = (struct lsa_QueryTrustedDomainInfo *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryTrustedDomainInfo replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfo, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryTrustedDomainInfo\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 27: { /* lsa_SetInformationTrustedDomain */
		struct lsa_SetInformationTrustedDomain *r2 = (struct lsa_SetInformationTrustedDomain *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetInformationTrustedDomain replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInformationTrustedDomain, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetInformationTrustedDomain\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 28: { /* lsa_OpenSecret */
		struct lsa_OpenSecret *r2 = (struct lsa_OpenSecret *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenSecret replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenSecret, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenSecret\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 29: { /* lsa_SetSecret */
		struct lsa_SetSecret *r2 = (struct lsa_SetSecret *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetSecret replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetSecret, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetSecret\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 30: { /* lsa_QuerySecret */
		struct lsa_QuerySecret *r2 = (struct lsa_QuerySecret *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QuerySecret replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QuerySecret, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QuerySecret\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 31: { /* lsa_LookupPrivValue */
		struct lsa_LookupPrivValue *r2 = (struct lsa_LookupPrivValue *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupPrivValue replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivValue, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupPrivValue\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 32: { /* lsa_LookupPrivName */
		struct lsa_LookupPrivName *r2 = (struct lsa_LookupPrivName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupPrivName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupPrivName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 33: { /* lsa_LookupPrivDisplayName */
		struct lsa_LookupPrivDisplayName *r2 = (struct lsa_LookupPrivDisplayName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupPrivDisplayName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupPrivDisplayName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupPrivDisplayName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 34: { /* lsa_DeleteObject */
		struct lsa_DeleteObject *r2 = (struct lsa_DeleteObject *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_DeleteObject replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_DeleteObject, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_DeleteObject\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 35: { /* lsa_EnumAccountsWithUserRight */
		struct lsa_EnumAccountsWithUserRight *r2 = (struct lsa_EnumAccountsWithUserRight *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumAccountsWithUserRight replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccountsWithUserRight, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumAccountsWithUserRight\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 36: { /* lsa_EnumAccountRights */
		struct lsa_EnumAccountRights *r2 = (struct lsa_EnumAccountRights *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumAccountRights replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumAccountRights, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumAccountRights\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 37: { /* lsa_AddAccountRights */
		struct lsa_AddAccountRights *r2 = (struct lsa_AddAccountRights *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_AddAccountRights replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_AddAccountRights, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_AddAccountRights\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 38: { /* lsa_RemoveAccountRights */
		struct lsa_RemoveAccountRights *r2 = (struct lsa_RemoveAccountRights *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_RemoveAccountRights replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RemoveAccountRights, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_RemoveAccountRights\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 39: { /* lsa_QueryTrustedDomainInfoBySid */
		struct lsa_QueryTrustedDomainInfoBySid *r2 = (struct lsa_QueryTrustedDomainInfoBySid *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryTrustedDomainInfoBySid replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfoBySid, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryTrustedDomainInfoBySid\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 40: { /* lsa_SetTrustedDomainInfo */
		struct lsa_SetTrustedDomainInfo *r2 = (struct lsa_SetTrustedDomainInfo *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetTrustedDomainInfo replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetTrustedDomainInfo, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetTrustedDomainInfo\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 41: { /* lsa_DeleteTrustedDomain */
		struct lsa_DeleteTrustedDomain *r2 = (struct lsa_DeleteTrustedDomain *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_DeleteTrustedDomain replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_DeleteTrustedDomain, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_DeleteTrustedDomain\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 42: { /* lsa_StorePrivateData */
		struct lsa_StorePrivateData *r2 = (struct lsa_StorePrivateData *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_StorePrivateData replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_StorePrivateData, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_StorePrivateData\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 43: { /* lsa_RetrievePrivateData */
		struct lsa_RetrievePrivateData *r2 = (struct lsa_RetrievePrivateData *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_RetrievePrivateData replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_RetrievePrivateData, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_RetrievePrivateData\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 44: { /* lsa_OpenPolicy2 */
		struct lsa_OpenPolicy2 *r2 = (struct lsa_OpenPolicy2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenPolicy2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenPolicy2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenPolicy2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 45: { /* lsa_GetUserName */
		struct lsa_GetUserName *r2 = (struct lsa_GetUserName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_GetUserName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_GetUserName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_GetUserName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 46: { /* lsa_QueryInfoPolicy2 */
		struct lsa_QueryInfoPolicy2 *r2 = (struct lsa_QueryInfoPolicy2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryInfoPolicy2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryInfoPolicy2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryInfoPolicy2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 47: { /* lsa_SetInfoPolicy2 */
		struct lsa_SetInfoPolicy2 *r2 = (struct lsa_SetInfoPolicy2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetInfoPolicy2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetInfoPolicy2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetInfoPolicy2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 48: { /* lsa_QueryTrustedDomainInfoByName */
		struct lsa_QueryTrustedDomainInfoByName *r2 = (struct lsa_QueryTrustedDomainInfoByName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryTrustedDomainInfoByName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryTrustedDomainInfoByName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryTrustedDomainInfoByName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 49: { /* lsa_SetTrustedDomainInfoByName */
		struct lsa_SetTrustedDomainInfoByName *r2 = (struct lsa_SetTrustedDomainInfoByName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetTrustedDomainInfoByName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetTrustedDomainInfoByName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetTrustedDomainInfoByName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 50: { /* lsa_EnumTrustedDomainsEx */
		struct lsa_EnumTrustedDomainsEx *r2 = (struct lsa_EnumTrustedDomainsEx *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_EnumTrustedDomainsEx replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_EnumTrustedDomainsEx, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_EnumTrustedDomainsEx\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 51: { /* lsa_CreateTrustedDomainEx */
		struct lsa_CreateTrustedDomainEx *r2 = (struct lsa_CreateTrustedDomainEx *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CreateTrustedDomainEx replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomainEx, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CreateTrustedDomainEx\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 52: { /* lsa_CloseTrustedDomainEx */
		struct lsa_CloseTrustedDomainEx *r2 = (struct lsa_CloseTrustedDomainEx *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CloseTrustedDomainEx replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CloseTrustedDomainEx, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CloseTrustedDomainEx\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 53: { /* lsa_QueryDomainInformationPolicy */
		struct lsa_QueryDomainInformationPolicy *r2 = (struct lsa_QueryDomainInformationPolicy *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_QueryDomainInformationPolicy replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_QueryDomainInformationPolicy, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_QueryDomainInformationPolicy\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 54: { /* lsa_SetDomainInformationPolicy */
		struct lsa_SetDomainInformationPolicy *r2 = (struct lsa_SetDomainInformationPolicy *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_SetDomainInformationPolicy replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_SetDomainInformationPolicy, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_SetDomainInformationPolicy\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 55: { /* lsa_OpenTrustedDomainByName */
		struct lsa_OpenTrustedDomainByName *r2 = (struct lsa_OpenTrustedDomainByName *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_OpenTrustedDomainByName replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_OpenTrustedDomainByName, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_OpenTrustedDomainByName\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 56: { /* lsa_TestCall */
		struct lsa_TestCall *r2 = (struct lsa_TestCall *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_TestCall replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_TestCall, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_TestCall\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 57: { /* lsa_LookupSids2 */
		struct lsa_LookupSids2 *r2 = (struct lsa_LookupSids2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupSids2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupSids2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 58: { /* lsa_LookupNames2 */
		struct lsa_LookupNames2 *r2 = (struct lsa_LookupNames2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupNames2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupNames2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 59: { /* lsa_CreateTrustedDomainEx2 */
		struct lsa_CreateTrustedDomainEx2 *r2 = (struct lsa_CreateTrustedDomainEx2 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CreateTrustedDomainEx2 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CreateTrustedDomainEx2, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CreateTrustedDomainEx2\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 60: { /* lsa_CREDRWRITE */
		struct lsa_CREDRWRITE *r2 = (struct lsa_CREDRWRITE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRWRITE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRWRITE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRWRITE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 61: { /* lsa_CREDRREAD */
		struct lsa_CREDRREAD *r2 = (struct lsa_CREDRREAD *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRREAD replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRREAD, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRREAD\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 62: { /* lsa_CREDRENUMERATE */
		struct lsa_CREDRENUMERATE *r2 = (struct lsa_CREDRENUMERATE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRENUMERATE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRENUMERATE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRENUMERATE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 63: { /* lsa_CREDRWRITEDOMAINCREDENTIALS */
		struct lsa_CREDRWRITEDOMAINCREDENTIALS *r2 = (struct lsa_CREDRWRITEDOMAINCREDENTIALS *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRWRITEDOMAINCREDENTIALS replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRWRITEDOMAINCREDENTIALS, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRWRITEDOMAINCREDENTIALS\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 64: { /* lsa_CREDRREADDOMAINCREDENTIALS */
		struct lsa_CREDRREADDOMAINCREDENTIALS *r2 = (struct lsa_CREDRREADDOMAINCREDENTIALS *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRREADDOMAINCREDENTIALS replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRREADDOMAINCREDENTIALS, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRREADDOMAINCREDENTIALS\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 65: { /* lsa_CREDRDELETE */
		struct lsa_CREDRDELETE *r2 = (struct lsa_CREDRDELETE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRDELETE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRDELETE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRDELETE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 66: { /* lsa_CREDRGETTARGETINFO */
		struct lsa_CREDRGETTARGETINFO *r2 = (struct lsa_CREDRGETTARGETINFO *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRGETTARGETINFO replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRGETTARGETINFO, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRGETTARGETINFO\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 67: { /* lsa_CREDRPROFILELOADED */
		struct lsa_CREDRPROFILELOADED *r2 = (struct lsa_CREDRPROFILELOADED *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRPROFILELOADED replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRPROFILELOADED, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRPROFILELOADED\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 68: { /* lsa_LookupNames3 */
		struct lsa_LookupNames3 *r2 = (struct lsa_LookupNames3 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupNames3 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames3, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupNames3\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 69: { /* lsa_CREDRGETSESSIONTYPES */
		struct lsa_CREDRGETSESSIONTYPES *r2 = (struct lsa_CREDRGETSESSIONTYPES *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRGETSESSIONTYPES replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRGETSESSIONTYPES, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRGETSESSIONTYPES\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 70: { /* lsa_LSARREGISTERAUDITEVENT */
		struct lsa_LSARREGISTERAUDITEVENT *r2 = (struct lsa_LSARREGISTERAUDITEVENT *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARREGISTERAUDITEVENT replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARREGISTERAUDITEVENT, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARREGISTERAUDITEVENT\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 71: { /* lsa_LSARGENAUDITEVENT */
		struct lsa_LSARGENAUDITEVENT *r2 = (struct lsa_LSARGENAUDITEVENT *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARGENAUDITEVENT replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARGENAUDITEVENT, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARGENAUDITEVENT\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 72: { /* lsa_LSARUNREGISTERAUDITEVENT */
		struct lsa_LSARUNREGISTERAUDITEVENT *r2 = (struct lsa_LSARUNREGISTERAUDITEVENT *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARUNREGISTERAUDITEVENT replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARUNREGISTERAUDITEVENT, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARUNREGISTERAUDITEVENT\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 73: { /* lsa_lsaRQueryForestTrustInformation */
		struct lsa_lsaRQueryForestTrustInformation *r2 = (struct lsa_lsaRQueryForestTrustInformation *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_lsaRQueryForestTrustInformation replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_lsaRQueryForestTrustInformation, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_lsaRQueryForestTrustInformation\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 74: { /* lsa_lsaRSetForestTrustInformation */
		struct lsa_lsaRSetForestTrustInformation *r2 = (struct lsa_lsaRSetForestTrustInformation *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_lsaRSetForestTrustInformation replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_lsaRSetForestTrustInformation, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_lsaRSetForestTrustInformation\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 75: { /* lsa_CREDRRENAME */
		struct lsa_CREDRRENAME *r2 = (struct lsa_CREDRRENAME *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_CREDRRENAME replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_CREDRRENAME, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_CREDRRENAME\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 76: { /* lsa_LookupSids3 */
		struct lsa_LookupSids3 *r2 = (struct lsa_LookupSids3 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupSids3 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupSids3, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupSids3\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 77: { /* lsa_LookupNames4 */
		struct lsa_LookupNames4 *r2 = (struct lsa_LookupNames4 *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LookupNames4 replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LookupNames4, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LookupNames4\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 78: { /* lsa_LSAROPENPOLICYSCE */
		struct lsa_LSAROPENPOLICYSCE *r2 = (struct lsa_LSAROPENPOLICYSCE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSAROPENPOLICYSCE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSAROPENPOLICYSCE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSAROPENPOLICYSCE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 79: { /* lsa_LSARADTREGISTERSECURITYEVENTSOURCE */
		struct lsa_LSARADTREGISTERSECURITYEVENTSOURCE *r2 = (struct lsa_LSARADTREGISTERSECURITYEVENTSOURCE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARADTREGISTERSECURITYEVENTSOURCE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTREGISTERSECURITYEVENTSOURCE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARADTREGISTERSECURITYEVENTSOURCE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 80: { /* lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE */
		struct lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE *r2 = (struct lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARADTUNREGISTERSECURITYEVENTSOURCE\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	case 81: { /* lsa_LSARADTREPORTSECURITYEVENT */
		struct lsa_LSARADTREPORTSECURITYEVENT *r2 = (struct lsa_LSARADTREPORTSECURITYEVENT *)r;
		if (dce_call->state_flags & DCESRV_CALL_STATE_FLAG_ASYNC) {
			DEBUG(5,("function lsa_LSARADTREPORTSECURITYEVENT replied async\n"));
		}
		if (DEBUGLEVEL >= 10 && dce_call->fault_code == 0) {
			NDR_PRINT_FUNCTION_DEBUG(lsa_LSARADTREPORTSECURITYEVENT, NDR_OUT | NDR_SET_VALUES, r2);
		}
		if (dce_call->fault_code != 0) {
			DBG_WARNING("dcerpc_fault %s in lsa_LSARADTREPORTSECURITYEVENT\n", dcerpc_errstr(mem_ctx, dce_call->fault_code));
		}
		break;
	}
	default:
		dce_call->fault_code = DCERPC_FAULT_OP_RNG_ERROR;
		break;
	}

	if (dce_call->fault_code != 0) {
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

NTSTATUS lsarpc__op_ndr_push(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct ndr_push *push, const void *r)
{
	enum ndr_err_code ndr_err;
	uint16_t opnum = dce_call->pkt.u.request.opnum;

	ndr_err = ndr_table_lsarpc.calls[opnum].ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		dce_call->fault_code = DCERPC_FAULT_NDR;
		return NT_STATUS_NET_WRITE_FAULT;
	}

	return NT_STATUS_OK;
}

NTSTATUS lsarpc__op_local(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, void *r)
{
	return lsarpc__op_dispatch_internal(dce_call, mem_ctx, r, S3COMPAT_RPC_DISPATCH_INTERNAL);
}

static const struct dcesrv_interface dcesrv_lsarpc_interface = {
	.name      = "lsarpc",
	.syntax_id = {{0x12345778,0x1234,0xabcd,{0xef,0x00},{0x01,0x23,0x45,0x67,0x89,0xab}},0.0},
	.bind      = lsarpc__op_bind,
	.unbind    = lsarpc__op_unbind,
	.ndr_pull  = lsarpc__op_ndr_pull,
	.dispatch  = lsarpc__op_dispatch,
	.reply     = lsarpc__op_reply,
	.ndr_push  = lsarpc__op_ndr_push,
	.local     = lsarpc__op_local,
#ifdef DCESRV_INTERFACE_LSARPC_FLAGS
	.flags     = DCESRV_INTERFACE_LSARPC_FLAGS
#else
	.flags     = 0
#endif
};

static NTSTATUS lsarpc__check_register_in_endpoint(const char *name, struct dcerpc_binding *binding) {
	enum dcerpc_transport_t transport = dcerpc_binding_get_transport(binding);

	/* If service is embedded, register only for ncacn_np
	 * see 8466b3c85e4b835e57e41776853093f4a0edc8b8
	 */
	if (rpc_service_mode(name) == RPC_SERVICE_MODE_EMBEDDED && (transport != NCACN_NP && transport != NCALRPC)) {
		DBG_INFO("Interface 'lsarpc' not registered in endpoint '%s' as service is embedded\n", name);
		return NT_STATUS_NOT_SUPPORTED;
	}

	return NT_STATUS_OK;
}

static NTSTATUS lsarpc__op_init_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	uint32_t i;
	NTSTATUS ret;
	struct dcerpc_binding *binding;

#ifdef DCESRV_INTERFACE_LSARPC_NCACN_NP_SECONDARY_ENDPOINT
	const char *ncacn_np_secondary_endpoint = DCESRV_INTERFACE_LSARPC_NCACN_NP_SECONDARY_ENDPOINT;
#else
	const char *ncacn_np_secondary_endpoint = NULL;
#endif

	for (i=0;i<ndr_table_lsarpc.endpoints->count;i++) {
		const char *name = ndr_table_lsarpc.endpoints->names[i];

		ret = dcerpc_parse_binding(dce_ctx, name, &binding);
		if (NT_STATUS_IS_ERR(ret)) {
			DBG_ERR("Failed to parse binding string '%s'\n", name);
			return ret;
		}

		ret = lsarpc__check_register_in_endpoint("lsarpc", binding);
		if (NT_STATUS_IS_ERR(ret)) {
			talloc_free(binding);
			continue;
		}
		talloc_free(binding);

		ret = dcesrv_interface_register(dce_ctx, name, ncacn_np_secondary_endpoint, &dcesrv_lsarpc_interface, NULL);
		if (!NT_STATUS_IS_OK(ret)) {
			DBG_ERR("Failed to register endpoint '%s'\n",name);
			return ret;
		}
	}

	return NT_STATUS_OK;
}

static NTSTATUS lsarpc__op_shutdown_server(struct dcesrv_context *dce_ctx, const struct dcesrv_endpoint_server *ep_server)
{
	return NT_STATUS_OK;
}

static bool lsarpc__op_interface_by_uuid(struct dcesrv_interface *iface, const struct GUID *uuid, uint32_t if_version)
{
	if (dcesrv_lsarpc_interface.syntax_id.if_version == if_version && GUID_equal(&dcesrv_lsarpc_interface.syntax_id.uuid, uuid)) {
		memcpy(iface,&dcesrv_lsarpc_interface, sizeof(*iface));
		return true;
	}

	return false;
}

static bool lsarpc__op_interface_by_name(struct dcesrv_interface *iface, const char *name)
{
	if (strcmp(dcesrv_lsarpc_interface.name, name)==0) {
		memcpy(iface, &dcesrv_lsarpc_interface, sizeof(*iface));
		return true;
	}

	return false;
}

static const struct dcesrv_endpoint_server lsarpc_ep_server = {
	/* fill in our name */
	.name = "lsarpc",

	/* Initialization flag */
	.initialized = false,

	/* fill in all the operations */
#ifdef DCESRV_INTERFACE_LSARPC_INIT_SERVER
	.init_server = DCESRV_INTERFACE_LSARPC_INIT_SERVER,
#else
	.init_server = lsarpc__op_init_server,
#endif
#ifdef DCESRV_INTERFACE_LSARPC_SHUTDOWN_SERVER
	.shutdown_server = DCESRV_INTERFACE_LSARPC_SHUTDOWN_SERVER,
#else
	.shutdown_server = lsarpc__op_shutdown_server,
#endif
	.interface_by_uuid = lsarpc__op_interface_by_uuid,
	.interface_by_name = lsarpc__op_interface_by_name
};

const struct dcesrv_endpoint_server *lsarpc_get_ep_server(void)
{
	return &lsarpc_ep_server;
}
